=Solr Ruby

A Ruby client for Apache Solr. Has transparent JRuby support by using "org.apache.solr.servlet.DirectSolrConnection" as a connection adapter.

To run tests:
  
  Copy a Solr 1.3.0 (or later) distribution into this directory and rename to "apache-solr"
  Start Solr HTTP:    rake start_test_server
  MRI Ruby:           rake
  JRuby:              jruby -S rake

To get a connection in Ruby:
  
  solr = Solr.connect(:http)

To get a direct connection in jRuby using DirectSolrConnection:
  
  solr = Solr.connect(:direct, :home_dir=>'/path/to/solr/home', :dist_dir=>'/path/to/solr/distribution')

You can set global connection options like:
  
  connection_opts = {:auto_commit=>false, :global_params=>{:wt=>:ruby, :echoParams=>'EXPLICIT'}}
  solr = Solr.connect(:http, {}, connection_opts)

Solr.connect also yields the adapter instance if a block is supplied:
  
  solr = Solr.connect(:http) do |net_http|
    net_http.class == Net::HTTP
    # set ssl options etc..
  end


== Requests
Once you have a connection, you can execute queries, updates etc..


=== Querying
  response = solr.query(:q=>'washington', :facet=>true, :facet.limit=>-1, :facet.field=cat, :facet.field=>inStock)
  response = solr.find_by_id(1)

Using the #search method makes building more complex Solr queries easier:
  
  response = solr.search 'my search', :filters=>{:price=>(0.00..10.00)}

====Pagination
Pagination is simplified by using the :page and :per_page params:

  response = solr.query(:page=>1, :per_page=>10, :q=>'*:*')
  response.per_page
  response.page_count
  response.current_page

If you use WillPaginate, just pass-in the response to the #will_paginate view helper:
  
  <%= will_paginate(@response) %>


=== Updating
Updating is done using native Ruby structures. Hashes are used for single documents and arrays are used for a collection of documents (hashes). These structures get turned into simple XML "messages".

Single document
  response = solr.add(:id=>1, :price=>1.00)

Multiple documents
  response = solr.add([{:id=>1, :price=>1.00}, {:id=>2, :price=>10.50}])

When adding, you can also supply "add" attributes and/or a block for digging into the Solr "add" params:

  doc = {:id=>1, :price=>1.00}
  solr.add(doc, {:allowDups=>false, :commitWithin=>10.0}) do |doc_attrs|
    doc_attrs[:boost] = 10.0
  end

Delete by id
  response = solr.delete_by_id(1)
or an array of ids
  response = solr.delete_by_id([1, 2, 3, 4])

Delete by query:
  response = solr.delete_by_query('price:1.00')
Delete by array of queries
  response = solr.delete_by_query(['price:1.00', 'price:10.00'])


Commit & Optimize
  solr.commit
  solr.optimize


==Response Formats
The default response format is Ruby. When the :wt param is set to :ruby, the response is eval'd and wrapped up in a nice Solr::Response class. You can get raw ruby by setting the :wt to "ruby" - notice, the string -- not a symbol. All other response formats are available as expected, :wt=>'xml' etc.. Currently, the only response format that gets eval'd and wrapped is :ruby.